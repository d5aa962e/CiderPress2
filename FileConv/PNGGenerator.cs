/*
 * Copyright 2023 faddenSoft
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
using System;
using System.Diagnostics;
using System.IO.Compression;

using CommonUtil;

namespace FileConv {
    /// <summary>
    /// PNG (Portable Network Graphics) generator.  This is a simple implementation that only
    /// works for Bitmap8/Bitmap32 objects.  This is required because the System.Drawing classes
    /// were marked Windows-only in .NET Core 6, with no cross-platform replacement provided.
    /// </summary>
    /// <remarks>
    /// <para>Because we use the 4/8-bit indexed color and 24-bit RGB color modes when possible,
    /// the files we create tend to be smaller than those generated by simple programs like
    /// MS Paint, which always use 32-bit ARGB.  Sophisticated programs like GIMP will usually
    /// do better.</para>
    /// </remarks>
    public static class PNGGenerator {
        public const string FILE_EXT = ".png";

        private static readonly byte[] HEADER = new byte[8] {
            0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a
        };
        private const uint CHUNK_IHDR = 0x49484452;
        private const uint CHUNK_PLTE = 0x504c5445;
        private const uint CHUNK_IDAT = 0x49444154;
        private const uint CHUNK_IEND = 0x49454e44;

        private enum ColorType {
            Palette = 3,        // palette | RGB
            RGB = 2,            // RGB
            RGBA = 6,           // RGB | Alpha
        }

        /// <summary>
        /// Generates a PNG image from the bitmap object.
        /// </summary>
        /// <param name="bmp">Bitmap source.</param>
        /// <param name="outStream">Output stream.  The stream will be left open.</param>
        public static void Generate(IBitmap bmp, Stream outStream) {
            bool needAlpha = NeedsAlphaChannel(bmp);
            Debug.WriteLine("PNGGenerator: " + bmp + ", needAlpha=" + needAlpha);

            ColorType colorType;
            byte bitDepth;
            if (bmp is Bitmap8) {
                Bitmap8 bmp8 = (Bitmap8)bmp;
                // Generate a 4bpp or 8bpp image with a palette.
                if (needAlpha) {
                    // PNG palette doesn't hold alpha values.
                    colorType = ColorType.RGBA;
                    bitDepth = 8;
                } else {
                    // In theory we could use 1-bit color for our B&W conversions.
                    colorType = ColorType.Palette;
                    if (bmp8.NumColors < 16) {
                        bitDepth = 4;
                    } else {
                        bitDepth = 8;
                    }
                }
            } else if (bmp is Bitmap32) {
                // Generate a truecolor image with 24 or 32 bits per pixel.
                bitDepth = 8;
                if (needAlpha) {
                    colorType = ColorType.RGBA;
                } else {
                    colorType = ColorType.RGB;
                }
            } else {
                throw new NotImplementedException();
            }

            // Write the PNG file header.
            outStream.Write(HEADER, 0, HEADER.Length);

            // Write the IHDR chunk.
            byte[] ihdrData = new byte[13];
            RawData.SetU32BE(ihdrData, 0, (uint)bmp.Width);
            RawData.SetU32BE(ihdrData, 4, (uint)bmp.Height);
            ihdrData[8] = bitDepth;
            ihdrData[9] = (byte)colorType;
            ihdrData[10] = 0;       // compression method: ZLIB deflate
            ihdrData[11] = 0;       // filter method: basic set
            ihdrData[12] = 0;       // interlace method: none
            WriteChunk(CHUNK_IHDR, ihdrData, 0, ihdrData.Length, outStream);

            // Write the PLTE chunk if we need one.
            if (colorType == ColorType.Palette) {
                byte[] plteData = GeneratePLTEData((Bitmap8)bmp);
                WriteChunk(CHUNK_PLTE, plteData, 0, plteData.Length, outStream);
            }

            // Generate the IDAT chunk.
            MemoryStream idatStream = new MemoryStream();
            GenerateIDATData(bmp, colorType, bitDepth, idatStream);
            WriteChunk(CHUNK_IDAT, idatStream.GetBuffer(), 0, (int)idatStream.Length, outStream);

            WriteChunk(CHUNK_IEND, RawData.EMPTY_BYTE_ARRAY, 0, 0, outStream);
        }

        /// <summary>
        /// Generates the PLTE chunk data, which is just R-G-B triples.
        /// </summary>
        private static byte[] GeneratePLTEData(Bitmap8 bmp8) {
            int[] colors = bmp8.GetColors()!;
            byte[] plteData = new byte[colors.Length * 3];
            for (int i = 0; i < colors.Length; i++) {
                int color = colors[i];                      // ARGB
                plteData[i * 3] = (byte)(color >> 16);      // red
                plteData[i * 3 + 1] = (byte)(color >> 8);   // green
                plteData[i * 3 + 2] = (byte)color;          // blue
            }
            return plteData;
        }

        /// <summary>
        /// Generates the data for the IDAT chunk.
        /// </summary>
        private static void GenerateIDATData(IBitmap bmp, ColorType colorType, byte bitDepth,
                Stream compStream) {
            // Create ZLIB stream to compress output as we generate it.  Set the "leave open" flag
            // so the memory stream stays open when the "using" statement closes the ZLibStream.
            using ZLibStream zlStream = new ZLibStream(compStream, CompressionLevel.Optimal, true);

            // Generate one row at a time into a temporary memory stream.
            for (int row = 0; row < bmp.Height; row++) {
                if (colorType == ColorType.Palette) {
                    // Indexed color.
                    Debug.Assert(bmp is Bitmap8);
                    if (bitDepth == 4) {
                        GenerateRow4((Bitmap8)bmp, row, zlStream);
                    } else {
                        GenerateRow8((Bitmap8)bmp, row, zlStream);
                    }
                } else if (colorType == ColorType.RGB) {
                    // Truecolor, no alpha.
                    Debug.Assert(bmp is Bitmap32);
                    GenerateRow24((Bitmap32)bmp, row, zlStream);
                } else if (colorType == ColorType.RGBA) {
                    // Indexed or truecolor with alpha.
                    if (bmp is Bitmap32) {
                        GenerateRow32((Bitmap32)bmp, row, zlStream);
                    } else {
                        GenerateRow32P((Bitmap8)bmp, row, zlStream);
                    }
                }
            }
        }

        private static void GenerateRow4(Bitmap8 bmp8, int row, Stream outStream) {
            outStream.WriteByte(0);     // no filter
            for (int col = 0; col < bmp8.Width; col += 2) {
                // First pixel goes in the high nibble.
                byte color = (byte)(bmp8.GetPixelIndex(col, row) << 4);
                // If width isn't odd, second pixel goes in the low nibble.
                if (col + 1 < bmp8.Width) {
                    color |= bmp8.GetPixelIndex(col + 1, row);
                }
                outStream.WriteByte(color);
            }
        }

        private static void GenerateRow8(Bitmap8 bmp8, int row, Stream outStream) {
            outStream.WriteByte(0);     // no filter
            for (int col = 0; col < bmp8.Width; col++) {
                outStream.WriteByte(bmp8.GetPixelIndex(col, row));
            }
        }

        private static void GenerateRow24(Bitmap32 bmp32, int row, Stream outStream) {
            outStream.WriteByte(0);     // no filter (TODO - try "up"?)
            for (int col = 0; col < bmp32.Width; col++) {
                int color = bmp32.GetPixel(col, row);
                RawData.WriteU24BE(outStream, (uint)(color & 0x00ffffff));
            }
        }

        private static void GenerateRow32(Bitmap32 bmp32, int row, Stream outStream) {
            outStream.WriteByte(0);     // no filter (TODO - try "up"?)
            for (int col = 0; col < bmp32.Width; col++) {
                int color = bmp32.GetPixel(col, row);
                RawData.WriteU32BE(outStream, (uint)color);
            }
        }

        private static void GenerateRow32P(Bitmap8 bmp8, int row, Stream outStream) {
            outStream.WriteByte(0);     // no filter
            int[] colors = bmp8.GetColors()!;
            for (int col = 0; col < bmp8.Width; col++) {
                byte colorIndex = bmp8.GetPixelIndex(col, row);
                uint argb = (uint)colors[colorIndex];
                uint rgba = (argb >> 24) | (argb << 8);
                RawData.WriteU32BE(outStream, rgba);
            }
        }

        /// <summary>
        /// Writes a PNG chunk to the stream.
        /// </summary>
        /// <param name="chunkType">Chunk type.</param>
        /// <param name="data">Data buffer.</param>
        /// <param name="offset">Offset to start of data in buffer.</param>
        /// <param name="length">Length of chunk.</param>
        /// <param name="stream">Stream to write data to.</param>
        private static void WriteChunk(uint chunkType, byte[] data, int offset, int length,
                Stream stream) {
            if (length - offset > data.Length) {
                throw new ArgumentException("Bad offset/length: offset=" + offset + " length=" +
                    length + " bufLen=" + data.Length);
            }

            // Compute CRC-32 on contents.  This includes the chunk type, but not the length.
            uint crc = 0;
            crc = CRC32.OnByte(crc, (byte)(chunkType >> 24));
            crc = CRC32.OnByte(crc, (byte)(chunkType >> 16));
            crc = CRC32.OnByte(crc, (byte)(chunkType >> 8));
            crc = CRC32.OnByte(crc, (byte)chunkType);
            crc = CRC32.OnBuffer(crc, data, offset, length);

            // The length does not include the chunk type or CRC.
            RawData.WriteU32BE(stream, (uint)length);
            RawData.WriteU32BE(stream, chunkType);
            stream.Write(data, offset, length);
            RawData.WriteU32BE(stream, crc);
        }

        /// <summary>
        /// Determines whether any of the colors in the bitmap have a non-1.0 alpha value.
        /// </summary>
        /// <param name="bmp">Bitmap to scan.</param>
        /// <returns>True if we need to output alpha values.</returns>
        private static bool NeedsAlphaChannel(IBitmap bmp) {
            if (bmp is Bitmap8) {
                int[]? palette = bmp.GetColors();
                if (palette == null) {
                    Debug.Assert(false);
                    return false;
                }
                for (int i = 0; i < palette.Length; i++) {
                    if ((palette[i] & 0xff000000) != 0xff000000) {
                        return true;
                    }
                }
                return false;
            } else {
                Bitmap32 bmp32 = (Bitmap32)bmp;
                for (int row = 0; row < bmp.Height; row++) {
                    for (int col = 0; col < bmp.Width; col++) {
                        int color = bmp32.GetPixel(col, row);
                        if ((color & 0xff000000) != 0xff000000) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }
    }
}
